#ifndef SCHEMATREE_H
#define SCHEMATREE_H

#include <QObject>
#include <QString>
#include <SchemaTypes.h>

/**
 * @class SchemaTree
 * @brief Дерево разбора логического выражения для построения схем
 *
 * @warning Все операторы имеют одинаковый приоритет!
 *
 * @details Особенности поддерживаемого синтаксиса:
 * - Бинарные операторы & (AND), | (OR), ^ (XOR)
 * - Унарный оператор ! (NOT)
 * - Операторы выполняются последовательно слева направо
 * - Разные операторы в одном выражении требуют явного указания
 *   приоритета через скобки
 * - Унарный NOT может находиться только в начале выражения
 *   или непосредственно перед переменной/скобками
 *
 * Класс преобразует строковое логическое выражение в дерево разбора,
 * вычисляет его размеры и предоставляет интерфейс для отрисовки.
 */
class SchemaTree : public QObject{
    Q_OBJECT

public:
    /**
     * @struct Node
     * @brief Узел дерева разбора
     *
     * Представляет один узел в дереве разбора
     * логического выражения.
    */
    struct Node
    {
        NodeType type;  ///< Тип узла
        QString value;  ///< Значение (для переменных и операторов)
        std::vector<std::unique_ptr<Node>> children;  ///< Дочерние узлы

        /**
         * @brief Конструктор узла
         * @param t Тип создаваемого узла
         * @param v Значение узла (по умолчанию пустая строка)
         */
        Node(NodeType t, const QString& v = "") : type(t), value(v) {}
    };

public:
    /**
     * @brief Конструктор дерева из логического выражения
     * @param text Логическое выражение в инфиксной нотации
     *
     * Поддерживаемые операторы:
     * - & (AND), | (OR), ^ (XOR), ! (NOT)
     *
     * Пример:
     * @code
     * SchemaTree tree("!((A|B)&!C)");
     * @endcode
     */
    explicit SchemaTree(const QString& text);

    ~SchemaTree() = default;

    /**
     * @brief Получить высоту дерева
     * @return Высота дерева в узлах
     *
     * Высота вычисляется как максимальная глубина от корня до листа.
     * Для пустого дерева возвращает 0.
     */
    int getHeight() const;

    /**
     * @brief Получить высоту узла
     * @param узел дерева
     * @return Высота узла в узлах
     *
     * Высота вычисляется как максимальная глубина от текущего узла до листа.
     * Для листа возвращает 0.
     */
    int getHeightNode(const std::unique_ptr<Node>& node) const;

    /**
     * @brief Получить ширину дерева
     * @return Ширина дерева в узлах
     *
     * Ширина вычисляется как максимальное количество узлов на одном уровне.
     * Для пустого дерева возвращает 0.
     */
    int getWidth() const;

    /**
     * @brief Получить ширину уровня
     * @param узел дерева
     * @return Ширина уровня в узлах
     *
     * Ширина вычисляется как максимальное количество узлов на одном уровне.
     * Для пустого уровня возвращает 0.
     */
    int getWidthNode(const std::unique_ptr<Node>& node) const;

    /**
     * @brief Получить корень дерева
     * @return Указатель на корневой узел дерева
     *
     * Корневой элемент дерева не имеющий родителя.
     * Возвращает nullptr если дерево пустое.
     */
    const Node* getRoot() const;

    /**
     * @brief Вывести дерево
     *
     * Выводит структуру дерева в консоль.
     */
    void printTree() const;

    /**
     * @brief Получить количество элементов типа VAR
     * @param узел дерева
     * @return Количество переменных в узле
     *
     * Рекурсивно считает количество элементов типа VAR у узла.
     * Для узла, у которого нет элементов типа VAR возвращает 0.
     */
    int countVarNodes(const std::unique_ptr<Node>& node) const;

private:
    /**
     * @brief Построить дерево из строкового выражения
     * @param text Входное логическое выражение
     *
     * Использует рекурсивный спуск для разбора выражения
     * и построения дерева.
     */
    void buildTree(const QString& text);

    /**
     * @brief Вспомогательная функция
     * @param text Входное логическое выражение
     * @return Список детей
     *
     * Вспомогательная функция построения дерева.
     * @see printTree()
     */
    std::vector<std::unique_ptr<Node>> buildTreeHelper(const QString& text);

    /**
     * @brief Посчитать высоту дерева
     * @param root корень дерева
     * @return Высота дерева в узлах
     *
     * Высота вычисляется как максимальная глубина от корня до листа.
     * Для пустого дерева возвращает 0.
     */
    int calculateHeight(const std::unique_ptr<Node>& node) const;

    /**
     * @brief Посчитать ширину дерева
     * @param root корень дерева
     * @return Ширина дерева в узлах
     *
     * Ширина вычисляется как максимальное количество узлов на одном уровне.
     * Для пустого дерева возвращает 0.
     */
    int calculateWidth(const std::unique_ptr<Node>& node) const;

    /**
     * @brief Вспомогательный метод отрисовки дерева
     * @param node узел дерева, prefix начало строки, isLast последний ли элемент
     *
     * Метод помогает функции отрисовывать дерево.
     * @see printTree()
     */
    void printNode(const Node* node, const QString& prefix, bool isLast) const;

    int height;  ///< Высота дерева для компоновки
    int width;  ///< Ширина дерева для компоновки
    std::unique_ptr<Node> root;  ///< Корень дерева

};

#endif // SCHEMATREE_H
